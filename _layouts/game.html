---
layout: default
---
<div id="story-game-root"></div>

<!-- React and ReactDOM -->
<script src="https://unpkg.com/react@17/umd/react.development.js"></script>
<script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>

<!-- Debug panel and file loading form -->
<div id="debug-panel" style="display: none; margin-bottom: 20px; padding: 15px; background: #f8f9fa; border: 1px solid #ddd; border-radius: 8px;">
  <h3>Debug Panel</h3>
  <p>Path attempted: <span id="path-attempted"></span></p>
  <p>Error details: <span id="error-details"></span></p>
  
  <form id="manual-node-form">
    <h4>Manually Load Story Node</h4>
    <p>If automatic loading fails, paste your node content below:</p>
    <textarea id="node-content" rows="10" style="width: 100%; font-family: monospace;"></textarea>
    <button type="submit" style="background: #3182ce; color: white; padding: 8px 16px; border: none; border-radius: 4px; margin-top: 10px;">Load Content</button>
  </form>
</div>

<!-- Game Component -->
<script>
const START_NODE = `---
node_id: start
title: Begin Your Journey as a Page
---

The year is 1328. You're a young lad of twelve, and today marks your first day as a page at Castle Hawksworth. You've dreamed of becoming a knight since you were old enough to hold a wooden sword, and now your journey begins.

Master Geoffrey, a stern but fair knight with graying hair at his temples, leads you through the massive stone walls of the castle. The bustle of castle life surrounds you - servants carrying baskets, guards patrolling, and nobles in fine clothing walking the grounds.

"Every knight must first master various skills and understand castle life," Master Geoffrey explains. "Today, you'll begin your training by helping in one area of the castle. This choice will start shaping your path."

He points to three directions:

[choices]
- text: "I'll help in the stables - I've always had a way with horses."
  next: b1
  rewards:
    skills: 
      - "Basic Horse Care"
    character_traits:
      - "Diligent"

- text: "I'll assist in the kitchen - I'm curious about castle provisions."
  next: b2
  rewards:
    skills: 
      - "Basic Food Preparation"
    character_traits:
      - "Observant"

- text: "I'll work with the messengers - I want to learn the castle layout."
  next: b3
  rewards:
    skills: 
      - "Castle Geography"
    character_traits:
      - "Inquisitive"
`;

// Include the direct choice parser
/**
 * A simplified, direct parser for story content with a focus on correctly parsing choices
 */
function directChoiceParser(nodeId, markdownText) {
  console.log(`Direct parsing for node: ${nodeId}`);
  
  try {
    // Split content into sections
    const parts = markdownText.split('[choices]');
    if (parts.length !== 2) {
      console.error('Could not find [choices] section in markdown');
      return {
        nodeId,
        title: 'Error Parsing Content',
        text: 'Could not find choices section.',
        choices: []
      };
    }
    
    // Get the content part (everything before [choices])
    const contentPart = parts[0];
    
    // Get the choices part (everything after [choices])
    const choicesPart = parts[1];
    
    // Extract frontmatter
    const frontmatterMatch = contentPart.match(/---\s+([\s\S]*?)\s+---/);
    let title = '';
    
    if (frontmatterMatch && frontmatterMatch[1]) {
      const frontmatterLines = frontmatterMatch[1].split('\n');
      for (const line of frontmatterLines) {
        if (line.startsWith('title:')) {
          title = line.substring('title:'.length).trim();
          break;
        }
      }
    }
    
    // Extract main content (between frontmatter and choices)
    let text = '';
    if (frontmatterMatch) {
      text = contentPart.substring(frontmatterMatch[0].length).trim();
    } else {
      text = contentPart.trim();
    }
    
    // Parse choices using a more direct regex approach
    const choices = [];
    
    // Match each choice block
    const choiceBlocks = choicesPart.split(/(?=\s*-\s*text:)/g);
    
    for (const block of choiceBlocks) {
      if (!block.trim()) continue;
      
      // Extract text
      const textMatch = block.match(/\s*-\s*text:\s*"?([^"\n]+)"?/);
      if (!textMatch) continue;
      
      const choice = {
        text: textMatch[1].trim(),
        next: null,
        rewards: {}
      };
      
      // Extract next
      const nextMatch = block.match(/\s+next:\s*([^\s\n]+)/);
      if (nextMatch) {
        choice.next = nextMatch[1].trim();
        console.log(`Direct parser found next: "${choice.next}" for choice: "${choice.text}"`);
      }
      
      // Add the choice
      choices.push(choice);
    }
    
    console.log(`Direct parser found ${choices.length} choices:`, choices);
    
    return {
      nodeId,
      title,
      text,
      choices
    };
  } catch (error) {
    console.error(`Error in direct parser for node ${nodeId}:`, error);
    return {
      nodeId,
      title: 'Error Parsing',
      text: `Error: ${error.message}`,
      choices: []
    };
  }
}

// Hardcoded story nodes as a fallback
const HARDCODED_NODES = {
  "start": START_NODE,
  
  "b1": `---
node_id: b1
title: The Stables
---

The smell of hay and horses fills your nostrils as you approach the stables. Thomas, the stable master, is a tall man with weathered hands and keen eyes. He looks you up and down as Master Geoffrey introduces you.

"So, you want to work with horses, do you?" Thomas asks, leading you past stalls where magnificent warhorses and swift coursers stand. "Let's see what you're made of. We've got a situation that needs handling."

You follow his gaze to a stall where a young, spirited horse is pawing at the ground, clearly agitated. Its coat is lathered with sweat, and none of the stable boys seem eager to approach.

"That's Thunder - new arrival and not yet used to castle life. We need to calm him down before he hurts himself. What's your thought, lad?"

[choices]
- text: "I'll try to calm Thunder myself - maybe if I approach slowly and speak softly..."
  next: c1
  rewards:
    skills: 
      - "Basic Horse Handling"
    character_traits:
      - "Brave"
    knowledge:
      - "Horse Body Language"

- text: "Perhaps we should get more experienced help - better to be careful with a frightened horse."
  next: c2
  rewards:
    character_traits:
      - "Prudent"
    knowledge:
      - "Stable Safety Protocols"
    relationships:
      - "Thomas (Stable Master) - Respect for Caution"`,
  
  "b2": `---
node_id: b2
title: The Kitchen
---

The warmth hits you first as you enter the castle kitchen, along with the rich aroma of fresh bread and herbs. Agnes, the head cook, is a stout woman with flour-dusted hands and sharp eyes that miss nothing. She pauses in her work at a large wooden table as Master Geoffrey makes introductions.

"Another pair of hands, eh?" she says, looking you over. "Well, timing couldn't be better. We've got a feast to prepare for tonight - Lord Edmund's returning from his travels." She gestures to the organized chaos around you, where kitchen boys and scullery maids hurry about their tasks.

"But first," she continues, lowering her voice, "we've got a more pressing matter. Someone's been taking extra food from the pantry - not much, mind you, but enough to notice. This morning, I saw a boy about your age sneaking away from the kitchen with a loaf of bread under his shirt."

[choices]
- text: "I could help you catch the thief and report them."
  next: c3
  rewards:
    character_traits:
      - "Dutiful"
    knowledge:
      - "Kitchen Security Protocols"
    relationships:
      - "Agnes (Head Cook) - Earned Trust"

- text: "Maybe we should find out why they're taking the food first? They might be hungry."
  next: c4
  rewards:
    character_traits:
      - "Compassionate"
      - "Diplomatic"
    knowledge:
      - "Castle Social Structure"`,
  
  "b3": `---
node_id: b3
title: Assist Messenger
---

"Keep up!" calls Thomas, the young messenger who's showing you the ropes. You jog behind him, trying to memorize the twisting corridors and hidden passages of Blackthorn Castle. Thomas seems to know every shortcut, every guard post, and every squeaky floorboard to avoid.

"A good messenger is like a ghost in the castle walls," he explains, leading you up a narrow servant's staircase. "We see everything but stay invisible." Throughout the day, you help deliver messages to what feels like every corner of the castle – from the knight's quarters to the lord's solar, from the guard towers to the deepest cellars.

You're learning fast. Already you can tell the difference between a regular guard patrol and the captain's inspection rounds. You know which corridors to use during meal times to avoid the rush of servants, and which windows provide the quickest views of approaching visitors.

As the sun begins to set, Thomas hands you a sealed message to deliver to the castle steward. "Last task of the day," he says. "Remember – third door past the tapestry of the hunting scene." But as you take the message, you notice something odd. There's a second piece of parchment stuck to the back, partially hidden, with what looks like a coded message written in charcoal.

[choices]
- text: "Read the hidden message, since it might be important for the castle's safety"
  next: c5
  rewards:
    skills: 
      - "Information Gathering"
    character_traits:
      - "Curiosity"
    knowledge:
      - "Coded Messages"
    relationships:
      - "Thomas (Messenger) - Potential Tension"

- text: "Stay loyal to the messenger's code and deliver the message without prying"
  next: c6
  rewards:
    skills: 
      - "Discretion"
    character_traits:
      - "Integrity"
    knowledge:
      - "Messenger's Ethical Code"
    relationships:
      - "Thomas (Messenger) - Trust"`
};

const StoryGame = () => {
  const parseStoryContent = (nodeId, markdownText) => {
    try {
      console.log(`Parsing content for node: ${nodeId}`);
      const lines = markdownText.split('\n');
      
      // Find frontmatter boundaries (---) 
      let frontmatterStart = -1;
      let frontmatterEnd = -1;
      
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].trim() === '---') {
          if (frontmatterStart === -1) {
            frontmatterStart = i;
          } else {
            frontmatterEnd = i;
            break;
          }
        }
      }
      
      if (frontmatterStart === -1 || frontmatterEnd === -1) {
        console.error('Error: Could not find frontmatter in markdown content');
        return null;
      }
      
      // Parse frontmatter
      const frontmatter = {};
      lines.slice(frontmatterStart + 1, frontmatterEnd).forEach(line => {
        if (line.includes(':')) {
          const [key, ...valueParts] = line.split(':');
          const value = valueParts.join(':').trim();
          frontmatter[key.trim()] = value;
        }
      });
      
      // Get main content (everything between frontmatter and [choices] section)
      let mainContentEnd = lines.findIndex(line => line.trim() === '[choices]');
      if (mainContentEnd === -1) mainContentEnd = lines.length;
      
      const mainContent = lines.slice(frontmatterEnd + 1, mainContentEnd).join('\n').trim();
      
      // Parse choices section
      const choices = [];
      let currentChoice = null;
      let inChoices = false;
      let inRewards = false;
      let currentRewardCategory = null;
      
      // Debug output for choices section
      console.log("Choice section starts at line:", mainContentEnd);
      if (mainContentEnd < lines.length) {
        console.log("Choice section lines:", lines.slice(mainContentEnd, lines.length));
      }
      
      for (let i = mainContentEnd; i < lines.length; i++) {
        const line = lines[i].trim();
        console.log(`Processing line ${i}: "${line}"`);
        
        if (line === '[choices]') {
          inChoices = true;
          console.log("Found [choices] marker, entering choices section");
          continue;
        }
        
        if (!inChoices) continue;
        
        if (line.startsWith('- text:')) {
          // Start a new choice
          if (currentChoice) {
            console.log("Adding choice:", currentChoice);
            choices.push(currentChoice);
          }
          
          const choiceText = line.substring('- text:'.length).trim().replace(/^"(.+)"$/, '$1');
          console.log(`Creating new choice with text: "${choiceText}"`);
          
          currentChoice = {
            text: choiceText,
            next: null, // Initialize with null to prevent undefined errors
            rewards: {}
          };
          inRewards = false;
        } else if (line.startsWith('  next:')) {
          if (currentChoice) {
            // Extract the next value, make sure it's not empty
            const nextValue = line.substring('  next:'.length).trim();
            currentChoice.next = nextValue || null;
            console.log(`Set next: "${nextValue}" for choice "${currentChoice.text}"`);
          }
        } else if (line.startsWith('  rewards:')) {
          inRewards = true;
          console.log("Entering rewards section");
        } else if (inRewards && line.startsWith('    ')) {
          // Inside rewards section
          if (line.endsWith(':')) {
            // This is a category like "skills:"
            currentRewardCategory = line.trim().slice(0, -1);
            if (!currentChoice.rewards[currentRewardCategory]) {
              currentChoice.rewards[currentRewardCategory] = [];
            }
            console.log(`Set reward category: "${currentRewardCategory}"`);
          } else if (line.startsWith('      -') && currentRewardCategory) {
            // This is a reward item
            const rewardValue = line.substring('      -'.length).trim().replace(/^"(.+)"$/, '$1');
            // Only add non-empty rewards
            if (rewardValue && rewardValue !== '""' && rewardValue !== "''") {
              currentChoice.rewards[currentRewardCategory].push(rewardValue);
              console.log(`Added reward: "${rewardValue}" to category "${currentRewardCategory}"`);
            }
          }
        }
      }
      
      // Add the last choice if there is one
      if (currentChoice) {
        console.log("Adding final choice:", currentChoice);
        choices.push(currentChoice);
      }
      
      console.log("Choices processed:", choices);
      
      return {
        nodeId: nodeId,
        title: frontmatter.title || '',
        text: mainContent,
        choices: choices.length > 0 ? choices : []
      };
    } catch (error) {
      console.error(`Error parsing story content for node ${nodeId}:`, error);
      document.getElementById('error-details').textContent = `Parser error: ${error.message}`;
      document.getElementById('debug-panel').style.display = 'block';
      return null;
    }
  };
  
  // Function to load story content from various sources
  const loadStoryContent = async (nodeId) => {
    console.log(`Loading story node: ${nodeId}`);
    
    // First try: Use hardcoded content if available
    if (HARDCODED_NODES[nodeId]) {
      console.log(`Using hardcoded content for ${nodeId}`);
      
      // Use the direct parser for simplicity and reliability
      const content = directChoiceParser(nodeId, HARDCODED_NODES[nodeId]);
      console.log("Parsed content:", content);
      
      if (content && content.choices) {
        console.log("Choices ready for rendering:", content.choices);
      }
      return content;
    }
    
    // Try loading from file (this might not work on GitHub Pages due to path issues)
    try {
      // Try different possible path patterns for GitHub Pages
      const possiblePaths = [
        `/_data/story/nodes/${nodeId}.md`,        // Most likely path based on your structure
        `/data/story/nodes/${nodeId}.md`,         // Alternative without leading underscore
        `/story/nodes/${nodeId}.md`,              // Another possible variation
        `/nodes/${nodeId}.md`,                    // Shortened path
        `/${nodeId}.md`,                          // Root path (least likely)
        `/socialstudies/_data/story/nodes/${nodeId}.md`,  // With potential prefix
        `/socialstudies/data/story/nodes/${nodeId}.md`    // Alternative with prefix
      ];
      
      let response = null;
      let successPath = null;
      
      // Debug output
      console.log('Loading story node:', nodeId);
      console.log('Possible paths:', possiblePaths);
      
      // Try each path until one works
      for (const path of possiblePaths) {
        console.log(`Trying path: ${path}`);
        document.getElementById('path-attempted').textContent = path;
        
        try {
          const resp = await fetch(path);
          if (resp.ok) {
            response = await resp.text();
            successPath = path;
            console.log(`Successfully loaded from: ${path}`);
            break;
          }
        } catch (e) {
          console.log(`Failed at path: ${path}`, e);
          document.getElementById('error-details').textContent = e.message;
        }
      }
      
      // If we successfully loaded content
      if (response) {
        return parseStoryContent(nodeId, response);
      } 
      
      // No content loaded, throw error to trigger fallback
      throw new Error(`Could not load content for node "${nodeId}" from any path. Check that the file exists in _data/story/nodes/ folder.`);
      
    } catch (error) {
      console.error(`Error loading story node ${nodeId}:`, error);
      document.getElementById('error-details').textContent = error.message;
      document.getElementById('debug-panel').style.display = 'block';
      
      // Check if this node has a fallback first
      if (HARDCODED_NODES[nodeId]) {
        return parseStoryContent(nodeId, HARDCODED_NODES[nodeId]);
      }
      
      // Return generic fallback error node
      return {
        nodeId: nodeId,
        title: 'Node Not Found',
        text: `The story node "${nodeId}" could not be loaded. This might be because:

1. The file doesn't exist yet in your _data/story/nodes/ folder
2. There might be a path issue in your GitHub Pages setup
3. The link from the previous node might have a typo

If you're a student: Please let your teacher know about this issue! In the meantime, you can go back and try a different path.

If you're the teacher: You'll need to create a file named "${nodeId}.md" in your _data/story/nodes/ folder. You can also add this node to the HARDCODED_NODES object in the game layout file for immediate testing.`,
        choices: []
      };
    }
  };

  const [currentNode, setCurrentNode] = React.useState('start');
  const [storyContent, setStoryContent] = React.useState(null);
  const [loading, setLoading] = React.useState(true);
  const [history, setHistory] = React.useState([]);
  const [journal, setJournal] = React.useState({
    skills: [],
    relationships: [],
    knowledge: [],
    items: [],
    character_traits: []
  });
  const [errorMessage, setErrorMessage] = React.useState('');

  // Load content when the current node changes
  React.useEffect(() => {
    const fetchContent = async () => {
      setLoading(true);
      setErrorMessage('');
      try {
        const content = await loadStoryContent(currentNode);
        if (content) {
          setStoryContent(content);
        } else {
          setErrorMessage(`Failed to load node: ${currentNode}`);
        }
      } catch (error) {
        console.error("Error in fetchContent:", error);
        setErrorMessage(`Error: ${error.message}`);
      } finally {
        setLoading(false);
      }
    };
    
    fetchContent();
  }, [currentNode]);
  
  // Set up manual node loading form handler
  React.useEffect(() => {
    const form = document.getElementById('manual-node-form');
    if (form) {
      form.addEventListener('submit', (e) => {
        e.preventDefault();
        const content = document.getElementById('node-content').value;
        if (content) {
          const parsedContent = parseStoryContent(currentNode, content);
          if (parsedContent) {
            setStoryContent(parsedContent);
            document.getElementById('debug-panel').style.display = 'none';
          }
        }
      });
    }
  }, []);

  const handleChoice = async (choice) => {
    // Add current node to history before moving
    setHistory(prev => [...prev, currentNode]);
    
    // Update journal with rewards
    if (choice.rewards) {
      setJournal(prev => {
        const newJournal = { ...prev };
        
        // Process each reward category
        Object.entries(choice.rewards).forEach(([category, items]) => {
          if (Array.isArray(items) && items.length > 0) {
            if (!newJournal[category]) newJournal[category] = [];
            // Add unique items only and filter out empty strings
            const filteredItems = items.filter(item => item && item.trim() !== '');
            newJournal[category] = [...new Set([...newJournal[category], ...filteredItems])];
          }
        });
        
        return newJournal;
      });
    }

    // Check if next node is defined
    if (!choice.next) {
      setErrorMessage(`Missing destination for choice: "${choice.text}". Check your markdown file for a missing "next:" property.`);
      return;
    }

    // Update current node - make sure the nodeId is lowercase to match your file naming
    const nextNode = choice.next.toLowerCase();
    setCurrentNode(nextNode);
  };
  
  const goBack = () => {
    if (history.length > 0) {
      // Get the last node from history
      const previousNode = history[history.length - 1];
      
      // Remove the last node from history
      setHistory(prev => prev.slice(0, -1));
      
      // Set current node to previous node
      setCurrentNode(previousNode);
    }
  };

  const resetGame = () => {
    console.log("Resetting game...");
    setCurrentNode('start');
    setHistory([]);
    setErrorMessage('');
    setJournal({
      skills: [],
      relationships: [],
      knowledge: [],
      items: [],
      character_traits: []
    });
  };

  // Journal Section Component
  const JournalSection = ({ title, items }) => {
    if (!items || items.length === 0) return null;
    return React.createElement('div', { className: 'journal-section' },
      React.createElement('h3', { key: 'title' }, title),
      React.createElement('ul', { key: 'list' }, 
        items.map((item, index) => 
          React.createElement('li', { key: index }, item)
        )
      )
    );
  };

  if (loading) {
    return React.createElement('div', { className: 'loading' }, 
      React.createElement('div', { className: 'spinner' }),
      'Loading story...'
    );
  }

  if (errorMessage) {
    return       React.createElement('div', { key: 'error' }, 
      `Error: ${errorMessage}`,
      React.createElement('button', {
        onClick: () => {
          resetGame();
          setErrorMessage('');
        },
        className: 'reset-button',
        style: { marginTop: '20px' }
      }, 'Return to Start')
    );
  }

  if (!storyContent) {
    return React.createElement('div', { className: 'error' }, 
      'Could not load story content',
      React.createElement('button', {
        onClick: resetGame,
        className: 'reset-button',
        style: { marginTop: '20px' }
      }, 'Return to Start')
    );
  }

  return React.createElement('div', { className: 'game-container' }, [
    // Main story section
    React.createElement('div', { key: 'story-section', className: 'story-section' }, [
      React.createElement('div', { key: 'node-id', className: 'node-id' },
        `Node: ${storyContent.nodeId}`
      ),
      React.createElement('h2', { key: 'title', className: 'game-title' }, 
        storyContent.title
      ),
      React.createElement('div', { key: 'story', className: 'story-text', 
        dangerouslySetInnerHTML: { __html: storyContent.text.replace(/\n/g, '<br>') }
      }),
      storyContent.choices && storyContent.choices.length > 0 ? 
        React.createElement('div', { key: 'choices', className: 'choice-container' }, 
          storyContent.choices.map((choice, index) => {
            console.log(`Rendering choice ${index}:`, choice);
            return React.createElement('button', {
              key: `choice-${index}`,
              onClick: () => handleChoice(choice),
              className: 'choice-button'
            }, choice.text);
          })
        ) : (
          // End of story node - display a message if there are no choices
          React.createElement('div', { key: 'story-end', className: 'story-end' },
            React.createElement('p', {}, "You've reached the end of this path of your adventure."),
            React.createElement('button', {
              onClick: resetGame,
              className: 'reset-button'
            }, 'Start a New Journey')
          )
        ),
      React.createElement('div', { key: 'game-controls', className: 'game-controls' }, [
        history.length > 0 && React.createElement('button', {
          key: 'back-button',
          onClick: goBack,
          className: 'back-button'
        }, 'Go Back'),
        React.createElement('button', {
          key: 'reset-button',
          onClick: resetGame,
          className: 'reset-button'
        }, 'Start Over')
      ])
    ]),
    
    // Journal section
    React.createElement('div', { key: 'journal', className: 'journal' }, [
      React.createElement('h2', { key: 'journal-title', className: 'journal-title' }, 
        'Your Journal'
      ),
      React.createElement(JournalSection, { 
        key: 'skills',
        title: 'Skills Learned',
        items: journal.skills 
      }),
      React.createElement(JournalSection, { 
        key: 'character_traits',
        title: 'Character Traits',
        items: journal.character_traits 
      }),
      React.createElement(JournalSection, { 
        key: 'knowledge',
        title: 'Knowledge Gained',
        items: journal.knowledge 
      }),
      React.createElement(JournalSection, { 
        key: 'relationships',
        title: 'Relationships',
        items: journal.relationships 
      }),
      React.createElement(JournalSection, { 
        key: 'items',
        title: 'Items Acquired',
        items: journal.items 
      })
    ])
  ]);
};

// Render the game
ReactDOM.render(
  React.createElement(StoryGame),
  document.getElementById('story-game-root')
);
</script>

<style>
.game-container {
  display: flex;
  max-width: 1200px;
  margin: 20px auto;
  gap: 20px;
  padding: 20px;
  min-height: 600px;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.story-section {
  flex: 2;
  background: white;
  padding: 30px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  position: relative;
  min-height: 400px;
  border: 1px solid #e2e8f0;
}

.journal {
  flex: 1;
  background: #f8f9fa;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  max-height: 80vh;
  overflow-y: auto;
  border: 1px solid #e2e8f0;
}

.node-id {
  position: absolute;
  top: 10px;
  right: 10px;
  font-size: 12px;
  color: #718096;
  background: #f7fafc;
  padding: 3px 8px;
  border-radius: 4px;
  border: 1px solid #e2e8f0;
}

.game-title {
  color: #2d3748;
  font-size: 24px;
  margin-bottom: 20px;
  border-bottom: 2px solid #e2e8f0;
  padding-bottom: 10px;
}

.journal-title {
  color: #2d3748;
  font-size: 20px;
  margin-bottom: 15px;
  padding-bottom: 10px;
  border-bottom: 2px solid #e2e8f0;
}

.story-text {
  font-size: 16px;
  line-height: 1.6;
  margin-bottom: 30px;
  color: #2d3748;
}

.choice-container {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-bottom: 60px;
}

.choice-button {
  background: #4a5568;
  color: white;
  padding: 12px 20px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
  transition: background 0.2s;
  text-align: left;
  line-height: 1.4;
}

.choice-button:hover {
  background: #2d3748;
}

.game-controls {
  position: absolute;
  bottom: 20px;
  left: 20px;
  display: flex;
  gap: 10px;
}

.back-button {
  background: #3182ce;
  color: white;
  padding: 8px 16px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  transition: background 0.2s;
}

.back-button:hover {
  background: #2c5282;
}

.reset-button {
  background: #e53e3e;
  color: white;
  padding: 8px 16px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  transition: background 0.2s;
}

.reset-button:hover {
  background: #c53030;
}

.loading {
  text-align: center;
  padding: 2rem;
  font-size: 1.2rem;
  color: #4a5568;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid rgba(0, 0, 0, 0.1);
  border-radius: 50%;
  border-top-color: #3182ce;
  animation: spin 1s linear infinite;
  margin-bottom: 15px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.error {
  text-align: center;
  padding: 2rem;
  color: #e53e3e;
  font-size: 1.2rem;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.story-end {
  text-align: center;
  padding: 20px;
  background: #f7fafc;
  border-radius: 8px;
  margin-bottom: 50px;
}

.journal-section {
  margin-bottom: 20px;
}

.journal-section h3 {
  color: #4a5568;
  font-size: 16px;
  margin-bottom: 8px;
  padding-bottom: 4px;
  border-bottom: 1px solid #e2e8f0;
}

.journal-section ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

.journal-section li {
  font-size: 14px;
  color: #4a5568;
  padding: 6px 0;
  border-bottom: 1px solid #edf2f7;
}

@media (max-width: 768px) {
  .game-container {
    flex-direction: column;
  }
  
  .journal {
    max-height: none;
  }
  
  .story-section {
    min-height: 300px;
  }

  .choice-container {
    margin-bottom: 80px;
  }

  .choice-button {
    font-size: 14px;
    padding: 10px 16px;
  }
}
</style>
