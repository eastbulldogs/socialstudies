---
layout: default
---
<div id="story-game-root"></div>

<!-- React and ReactDOM -->
<script src="https://unpkg.com/react@17/umd/react.development.js"></script>
<script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>

<!-- Debug panel and file loading form -->
<div id="debug-panel" style="display: none; margin-bottom: 20px; padding: 15px; background: #f8f9fa; border: 1px solid #ddd; border-radius: 8px;">
  <h3>Debug Panel</h3>
  <p>Path attempted: <span id="path-attempted"></span></p>
  <p>Error details: <span id="error-details"></span></p>
  
  <form id="manual-node-form">
    <h4>Manually Load Story Node</h4>
    <p>If automatic loading fails, paste your node content below:</p>
    <textarea id="node-content" rows="10" style="width: 100%; font-family: monospace;"></textarea>
    <button type="submit" style="background: #3182ce; color: white; padding: 8px 16px; border: none; border-radius: 4px; margin-top: 10px;">Load Content</button>
  </form>
</div>

<!-- Game Component -->
<script>
// Hardcoded story nodes as a fallback
const HARDCODED_NODES = {
  "start": `---
node_id: start
title: Begin Your Journey as a Page
---

The year is 1328. You're a young lad of twelve, and today marks your first day as a page at Castle Hawksworth. You've dreamed of becoming a knight since you were old enough to hold a wooden sword, and now your journey begins.

Master Geoffrey, a stern but fair knight with graying hair at his temples, leads you through the massive stone walls of the castle. The bustle of castle life surrounds you - servants carrying baskets, guards patrolling, and nobles in fine clothing walking the grounds.

"Every knight must first master various skills and understand castle life," Master Geoffrey explains. "Today, you'll begin your training by helping in one area of the castle. This choice will start shaping your path."

He points to three directions:

[choices]
- text: "I'll help in the stables - I've always had a way with horses."
  next: b1
  rewards:
    skills: 
      - "Basic Horse Care"
    character_traits:
      - "Diligent"

- text: "I'll assist in the kitchen - I'm curious about castle provisions."
  next: b2
  rewards:
    skills: 
      - "Basic Food Preparation"
    character_traits:
      - "Observant"

- text: "I'll work with the messengers - I want to learn the castle layout."
  next: b3
  rewards:
    skills: 
      - "Castle Geography"
    character_traits:
      - "Inquisitive"`,
  
  "b1": `---
node_id: b1
title: The Stables
---

The smell of hay and horses fills your nostrils as you approach the stables. Thomas, the stable master, is a tall man with weathered hands and keen eyes. He looks you up and down as Master Geoffrey introduces you.

"So, you want to work with horses, do you?" Thomas asks, leading you past stalls where magnificent warhorses and swift coursers stand. "Let's see what you're made of. We've got a situation that needs handling."

You follow his gaze to a stall where a young, spirited horse is pawing at the ground, clearly agitated. Its coat is lathered with sweat, and none of the stable boys seem eager to approach.

"That's Thunder - new arrival and not yet used to castle life. We need to calm him down before he hurts himself. What's your thought, lad?"

[choices]
- text: "I'll try to calm Thunder myself - maybe if I approach slowly and speak softly..."
  next: c1
  rewards:
    skills: 
      - "Basic Horse Handling"
    character_traits:
      - "Brave"
    knowledge:
      - "Horse Body Language"

- text: "Perhaps we should get more experienced help - better to be careful with a frightened horse."
  next: c2
  rewards:
    character_traits:
      - "Prudent"
    knowledge:
      - "Stable Safety Protocols"
    relationships:
      - "Thomas (Stable Master) - Respect for Caution"`
};

const StoryGame = () => {
  // Function to parse story content from markdown text
  const parseStoryContent = (nodeId, markdownText) => {
    try {
      console.log(`Parsing content for node: ${nodeId}`);
      const lines = markdownText.split('\n');
      
      // Find frontmatter boundaries (---) 
      let frontmatterStart = -1;
      let frontmatterEnd = -1;
      
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].trim() === '---') {
          if (frontmatterStart === -1) {
            frontmatterStart = i;
          } else {
            frontmatterEnd = i;
            break;
          }
        }
      }
      
      if (frontmatterStart === -1 || frontmatterEnd === -1) {
        console.error('Error: Could not find frontmatter in markdown content');
        return null;
      }
      
      // Parse frontmatter
      const frontmatter = {};
      lines.slice(frontmatterStart + 1, frontmatterEnd).forEach(line => {
        if (line.includes(':')) {
          const [key, ...valueParts] = line.split(':');
          const value = valueParts.join(':').trim();
          frontmatter[key.trim()] = value;
        }
      });
      
      // Get main content (everything between frontmatter and [choices] section)
      let mainContentEnd = lines.findIndex(line => line.trim() === '[choices]');
      if (mainContentEnd === -1) mainContentEnd = lines.length;
      
      const mainContent = lines.slice(frontmatterEnd + 1, mainContentEnd).join('\n').trim();
      
      // Parse choices section
      const choices = [];
      let currentChoice = null;
      let inChoices = false;
      let inRewards = false;
      let currentRewardCategory = null;
      
      for (let i = mainContentEnd; i < lines.length; i++) {
        const line = lines[i].trim();
        
        if (line === '[choices]') {
          inChoices = true;
          continue;
        }
        
        if (!inChoices) continue;
        
        if (line.startsWith('- text:')) {
          // Start a new choice
          if (currentChoice) {
            choices.push(currentChoice);
          }
          
          currentChoice = {
            text: line.substring('- text:'.length).trim().replace(/^"(.+)"$/, '$1'),
            next: null, // Initialize with null to prevent undefined errors
            rewards: {}
          };
          inRewards = false;
        } else if (line.startsWith('  next:')) {
          if (currentChoice) {
            // Extract the next value, make sure it's not empty
            const nextValue = line.substring('  next:'.length).trim();
            currentChoice.next = nextValue || null;
          }
        } else if (line.startsWith('  rewards:')) {
          inRewards = true;
        } else if (inRewards && line.startsWith('    ')) {
          // Inside rewards section
          if (line.endsWith(':')) {
            // This is a category like "skills:"
            currentRewardCategory = line.trim().slice(0, -1);
            if (!currentChoice.rewards[currentRewardCategory]) {
              currentChoice.rewards[currentRewardCategory] = [];
            }
          } else if (line.startsWith('      -') && currentRewardCategory) {
            // This is a reward item
            const rewardValue = line.substring('      -'.length).trim().replace(/^"(.+)"$/, '$1');
            // Only add non-empty rewards
            if (rewardValue && rewardValue !== '""' && rewardValue !== "''") {
              currentChoice.rewards[currentRewardCategory].push(rewardValue);
            }
          }
        }
      }
      
      // Add the last choice if there is one
      if (currentChoice) {
        choices.push(currentChoice);
      }
      
      return {
        nodeId: nodeId,
        title: frontmatter.title || '',
        text: mainContent,
        choices: choices.length > 0 ? choices : null
      };
    } catch (error) {
      console.error(`Error parsing story content for node ${nodeId}:`, error);
      document.getElementById('error-details').textContent = `Parser error: ${error.message}`;
      document.getElementById('debug-panel').style.display = 'block';
      return null;
    }
  };
  
  // Function to load story content from various sources
  const loadStoryContent = async (nodeId) => {
    console.log(`Loading story node: ${nodeId}`);
    
    // First try: Use hardcoded content if available
    if (HARDCODED_NODES[nodeId]) {
      console.log(`Using hardcoded content for ${nodeId}`);
      return parseStoryContent(nodeId, HARDCODED_NODES[nodeId]);
    }
    
    // Try loading from file (this might not work on GitHub Pages due to path issues)
    try {
      // Try different possible path patterns for GitHub Pages
      const possiblePaths = [
        `/_data/story/nodes/${nodeId}.md`,        // Most likely path based on your structure
        `/data/story/nodes/${nodeId}.md`,         // Alternative without leading underscore
        `/story/nodes/${nodeId}.md`,              // Another possible variation
        `/nodes/${nodeId}.md`,                    // Shortened path
        `/${nodeId}.md`,                          // Root path (least likely)
        `/socialstudies/_data/story/nodes/${nodeId}.md`,  // With potential prefix
        `/socialstudies/data/story/nodes/${nodeId}.md`    // Alternative with prefix
      ];
      
      let response = null;
      let successPath = null;
      
      // Debug output
      console.log('Loading story node:', nodeId);
      console.log('Possible paths:', possiblePaths);
      
      // Try each path until one works
      for (const path of possiblePaths) {
        console.log(`Trying path: ${path}`);
        document.getElementById('path-attempted').textContent = path;
        
        try {
          const resp = await fetch(path);
          if (resp.ok) {
            response = await resp.text();
            successPath = path;
            console.log(`Successfully loaded from: ${path}`);
            break;
          }
        } catch (e) {
          console.log(`Failed at path: ${path}`, e);
          document.getElementById('error-details').textContent = e.message;
        }
      }
      
      // If we successfully loaded content
      if (response) {
        return parseStoryContent(nodeId, response);
      } 
      
      // No content loaded, throw error to trigger fallback
      throw new Error(`Could not load content for node "${nodeId}" from any path. Check that the file exists in _data/story/nodes/ folder.`);
      
    } catch (error) {
      console.error(`Error loading story node ${nodeId}:`, error);
      document.getElementById('error-details').textContent = error.message;
      document.getElementById('debug-panel').style.display = 'block';
      
      // Check if this node has a fallback first
      if (HARDCODED_NODES[nodeId]) {
        return parseStoryContent(nodeId, HARDCODED_NODES[nodeId]);
      }
      
      // Return generic fallback error node
      return {
        nodeId: nodeId,
        title: 'Node Not Found',
        text: `The story node "${nodeId}" could not be loaded. This might be because:

1. The file doesn't exist yet in your _data/story/nodes/ folder
2. There might be a path issue in your GitHub Pages setup
3. The link from the previous node might have a typo

If you're a student: Please let your teacher know about this issue! In the meantime, you can go back and try a different path.

If you're the teacher: You'll need to create a file named "${nodeId}.md" in your _data/story/nodes/ folder. You can also add this node to the HARDCODED_NODES object in the game layout file for immediate testing.`,
        choices: []
      };
    }
  };

  const [currentNode, setCurrentNode] = React.useState('start');
  const [storyContent, setStoryContent] = React.useState(null);
  const [loading, setLoading] = React.useState(true);
  const [history, setHistory] = React.useState([]);
  const [journal, setJournal] = React.useState({
    skills: [],
    relationships: [],
    knowledge: [],
    items: [],
    character_traits: []
  });
  const [errorMessage, setErrorMessage] = React.useState('');

  // Load content when the current node changes
  React.useEffect(() => {
    const fetchContent = async () => {
      setLoading(true);
      setErrorMessage('');
      try {
        const content = await loadStoryContent(currentNode);
        if (content) {
          setStoryContent(content);
        } else {
          setErrorMessage(`Failed to load node: ${currentNode}`);
        }
      } catch (error) {
        console.error("Error in fetchContent:", error);
        setErrorMessage(`Error: ${error.message}`);
      } finally {
        setLoading(false);
      }
    };
    
    fetchContent();
  }, [currentNode]);
  
  // Set up manual node loading form handler
  React.useEffect(() => {
    const form = document.getElementById('manual-node-form');
    if (form) {
      form.addEventListener('submit', (e) => {
        e.preventDefault();
        const content = document.getElementById('node-content').value;
        if (content) {
          const parsedContent = parseStoryContent(currentNode, content);
          if (parsedContent) {
            setStoryContent(parsedContent);
            document.getElementById('debug-panel').style.display = 'none';
          }
        }
      });
    }
  }, []);

  const handleChoice = async (choice) => {
    // Add current node to history before moving
    setHistory(prev => [...prev, currentNode]);
    
    // Update journal with rewards
    if (choice.rewards) {
      setJournal(prev => {
        const newJournal = { ...prev };
        
        // Process each reward category
        Object.entries(choice.rewards).forEach(([category, items]) => {
          if (Array.isArray(items) && items.length > 0) {
            if (!newJournal[category]) newJournal[category] = [];
            // Add unique items only and filter out empty strings
            const filteredItems = items.filter(item => item && item.trim() !== '');
            newJournal[category] = [...new Set([...newJournal[category], ...filteredItems])];
          }
        });
        
        return newJournal;
      });
    }

    // Check if next node is defined
    if (!choice.next) {
      setErrorMessage(`Missing destination for choice: "${choice.text}". Check your markdown file for a missing "next:" property.`);
      return;
    }

    // Update current node - make sure the nodeId is lowercase to match your file naming
    const nextNode = choice.next.toLowerCase();
    setCurrentNode(nextNode);
  };
  
  const goBack = () => {
    if (history.length > 0) {
      // Get the last node from history
      const previousNode = history[history.length - 1];
      
      // Remove the last node from history
      setHistory(prev => prev.slice(0, -1));
      
      // Set current node to previous node
      setCurrentNode(previousNode);
    }
  };

  const resetGame = async () => {
    setCurrentNode('start');
    setHistory([]);
    setJournal({
      skills: [],
      relationships: [],
      knowledge: [],
      items: [],
      character_traits: []
    });
  };

  // Journal Section Component
  const JournalSection = ({ title, items }) => {
    if (!items || items.length === 0) return null;
    return React.createElement('div', { className: 'journal-section' },
      React.createElement('h3', { key: 'title' }, title),
      React.createElement('ul', { key: 'list' }, 
        items.map((item, index) => 
          React.createElement('li', { key: index }, item)
        )
      )
    );
  };

  if (loading) {
    return React.createElement('div', { className: 'loading' }, 
      React.createElement('div', { className: 'spinner' }),
      'Loading story...'
    );
  }

  if (errorMessage) {
    return       React.createElement('div', { key: 'error' }, 
      `Error: ${errorMessage}`,
      React.createElement('button', {
        onClick: () => {
          resetGame();
          setErrorMessage('');
        },
        className: 'reset-button',
        style: { marginTop: '20px' }
      }, 'Return to Start')
    );
  }

  if (!storyContent) {
    return React.createElement('div', { className: 'error' }, 
      'Could not load story content',
      React.createElement('button', {
        onClick: resetGame,
        className: 'reset-button',
        style: { marginTop: '20px' }
      }, 'Return to Start')
    );
  }

  return React.createElement('div', { className: 'game-container' }, [
    // Main story section
    React.createElement('div', { key: 'story-section', className: 'story-section' }, [
      React.createElement('div', { key: 'node-id', className: 'node-id' },
        `Node: ${storyContent.nodeId}`
      ),
      React.createElement('h2', { key: 'title', className: 'game-title' }, 
        storyContent.title
      ),
      React.createElement('div', { key: 'story', className: 'story-text', 
        dangerouslySetInnerHTML: { __html: storyContent.text.replace(/\n/g, '<br>') }
      }),
      storyContent.choices && storyContent.choices.length > 0 ? 
        React.createElement('div', { key: 'choices', className: 'choice-container' }, 
          storyContent.choices.map((choice, index) => 
            React.createElement('button', {
              key: `choice-${index}`,
              onClick: () => handleChoice(choice),
              className: 'choice-button'
            }, choice.text)
          )
        ) : (
          // End of story node - display a message if there are no choices
          React.createElement('div', { key: 'story-end', className: 'story-end' },
            React.createElement('p', {}, "You've reached the end of this path of your adventure."),
            React.createElement('button', {
              onClick: resetGame,
              className: 'reset-button'
            }, 'Start a New Journey')
          )
        ),
      React.createElement('div', { key: 'game-controls', className: 'game-controls' }, [
        history.length > 0 && React.createElement('button', {
          key: 'back-button',
          onClick: goBack,
          className: 'back-button'
        }, 'Go Back'),
        React.createElement('button', {
          key: 'reset-button',
          onClick: resetGame,
          className: 'reset-button'
        }, 'Start Over')
      ])
    ]),
    
    // Journal section
    React.createElement('div', { key: 'journal', className: 'journal' }, [
      React.createElement('h2', { key: 'journal-title', className: 'journal-title' }, 
        'Your Journal'
      ),
      React.createElement(JournalSection, { 
        key: 'skills',
        title: 'Skills Learned',
        items: journal.skills 
      }),
      React.createElement(JournalSection, { 
        key: 'character_traits',
        title: 'Character Traits',
        items: journal.character_traits 
      }),
      React.createElement(JournalSection, { 
        key: 'knowledge',
        title: 'Knowledge Gained',
        items: journal.knowledge 
      }),
      React.createElement(JournalSection, { 
        key: 'relationships',
        title: 'Relationships',
        items: journal.relationships 
      }),
      React.createElement(JournalSection, { 
        key: 'items',
        title: 'Items Acquired',
        items: journal.items 
      })
    ])
  ]);
};

// Render the game
ReactDOM.render(
  React.createElement(StoryGame),
  document.getElementById('story-game-root')
);
</script>

<style>
.game-container {
  display: flex;
  max-width: 1200px;
  margin: 20px auto;
  gap: 20px;
  padding: 20px;
  min-height: 600px;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.story-section {
  flex: 2;
  background: white;
  padding: 30px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  position: relative;
  min-height: 400px;
  border: 1px solid #e2e8f0;
}

.journal {
  flex: 1;
  background: #f8f9fa;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  max-height: 80vh;
  overflow-y: auto;
  border: 1px solid #e2e8f0;
}

.node-id {
  position: absolute;
  top: 10px;
  right: 10px;
  font-size: 12px;
  color: #718096;
  background: #f7fafc;
  padding: 3px 8px;
  border-radius: 4px;
  border: 1px solid #e2e8f0;
}

.game-title {
  color: #2d3748;
  font-size: 24px;
  margin-bottom: 20px;
  border-bottom: 2px solid #e2e8f0;
  padding-bottom: 10px;
}

.journal-title {
  color: #2d3748;
  font-size: 20px;
  margin-bottom: 15px;
  padding-bottom: 10px;
  border-bottom: 2px solid #e2e8f0;
}

.story-text {
  font-size: 16px;
  line-height: 1.6;
  margin-bottom: 30px;
  color: #2d3748;
}

.choice-container {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-bottom: 60px;
}

.choice-button {
  background: #4a5568;
  color: white;
  padding: 12px 20px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
  transition: background 0.2s;
  text-align: left;
  line-height: 1.4;
}

.choice-button:hover {
  background: #2d3748;
}

.game-controls {
  position: absolute;
  bottom: 20px;
  left: 20px;
  display: flex;
  gap: 10px;
}

.back-button {
  background: #3182ce;
  color: white;
  padding: 8px 16px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  transition: background 0.2s;
}

.back-button:hover {
  background: #2c5282;
}

.reset-button {
  background: #e53e3e;
  color: white;
  padding: 8px 16px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  transition: background 0.2s;
}

.reset-button:hover {
  background: #c53030;
}

.loading {
  text-align: center;
  padding: 2rem;
  font-size: 1.2rem;
  color: #4a5568;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid rgba(0, 0, 0, 0.1);
  border-radius: 50%;
  border-top-color: #3182ce;
  animation: spin 1s linear infinite;
  margin-bottom: 15px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.error {
  text-align: center;
  padding: 2rem;
  color: #e53e3e;
  font-size: 1.2rem;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.story-end {
  text-align: center;
  padding: 20px;
  background: #f7fafc;
  border-radius: 8px;
  margin-bottom: 50px;
}

.journal-section {
  margin-bottom: 20px;
}

.journal-section h3 {
  color: #4a5568;
  font-size: 16px;
  margin-bottom: 8px;
  padding-bottom: 4px;
  border-bottom: 1px solid #e2e8f0;
}

.journal-section ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

.journal-section li {
  font-size: 14px;
  color: #4a5568;
  padding: 6px 0;
  border-bottom: 1px solid #edf2f7;
}

@media (max-width: 768px) {
  .game-container {
    flex-direction: column;
  }
  
  .journal {
    max-height: none;
  }
  
  .story-section {
    min-height: 300px;
  }

  .choice-container {
    margin-bottom: 80px;
  }

  .choice-button {
    font-size: 14px;
    padding: 10px 16px;
  }
}
</style>
