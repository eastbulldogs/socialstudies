---
layout: default
---
<div id="story-game-root"></div>

<!-- React and ReactDOM -->
<script src="https://unpkg.com/react@17/umd/react.development.js"></script>
<script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>

<!-- Debug panel and file loading form -->
<div id="debug-panel" style="display: none; margin-bottom: 20px; padding: 15px; background: #f8f9fa; border: 1px solid #ddd; border-radius: 8px;">
  <h3>Debug Panel</h3>
  <p>Path attempted: <span id="path-attempted"></span></p>
  <p>Error details: <span id="error-details"></span></p>
  
  <form id="manual-node-form">
    <h4>Manually Load Story Node</h4>
    <p>If automatic loading fails, paste your node content below:</p>
    <textarea id="node-content" rows="10" style="width: 100%; font-family: monospace;"></textarea>
    <button type="submit" style="background: #3182ce; color: white; padding: 8px 16px; border: none; border-radius: 4px; margin-top: 10px;">Load Content</button>
  </form>
</div>

<!-- Game Component -->
<script>
const START_NODE = `---
node_id: start
title: Begin Your Journey as a Page
---

The year is 1328. You're a young lad of twelve, and today marks your first day as a page at Castle Hawksworth. You've dreamed of becoming a knight since you were old enough to hold a wooden sword, and now your journey begins.

Master Geoffrey, a stern but fair knight with graying hair at his temples, leads you through the massive stone walls of the castle. The bustle of castle life surrounds you - servants carrying baskets, guards patrolling, and nobles in fine clothing walking the grounds.

"Every knight must first master various skills and understand castle life," Master Geoffrey explains. "Today, you'll begin your training by helping in one area of the castle. This choice will start shaping your path."

He points to three directions:

[choices]
- text: "I'll help in the stables - I've always had a way with horses."
  next: b1
  rewards:
    skills: 
      - "Basic Horse Care"
    character_traits:
      - "Diligent"

- text: "I'll assist in the kitchen - I'm curious about castle provisions."
  next: b2
  rewards:
    skills: 
      - "Basic Food Preparation"
    character_traits:
      - "Observant"

- text: "I'll work with the messengers - I want to learn the castle layout."
  next: b3
  rewards:
    skills: 
      - "Castle Geography"
    character_traits:
      - "Inquisitive"
`;

// Include the direct choice parser
/**
 * A simplified, direct parser for story content with a focus on correctly parsing choices
 */
function directChoiceParser(nodeId, markdownText) {
  console.log(`Direct parsing for node: ${nodeId}`);
  
  try {
    // Split content into sections
    const parts = markdownText.split('[choices]');
    if (parts.length !== 2) {
      console.error('Could not find [choices] section in markdown');
      return {
        nodeId,
        title: 'Error Parsing Content',
        text: 'Could not find choices section.',
        choices: []
      };
    }
    
    // Get the content part (everything before [choices])
    const contentPart = parts[0];
    
    // Get the choices part (everything after [choices])
    const choicesPart = parts[1];
    
    // Extract frontmatter
    const frontmatterMatch = contentPart.match(/---\s+([\s\S]*?)\s+---/);
    let title = '';
    
    if (frontmatterMatch && frontmatterMatch[1]) {
      const frontmatterLines = frontmatterMatch[1].split('\n');
      for (const line of frontmatterLines) {
        if (line.startsWith('title:')) {
          title = line.substring('title:'.length).trim();
          break;
        }
      }
    }
    
    // Extract main content (between frontmatter and choices)
    let text = '';
    if (frontmatterMatch) {
      text = contentPart.substring(frontmatterMatch[0].length).trim();
    } else {
      text = contentPart.trim();
    }
    
    // Parse choices using a more direct regex approach
    const choices = [];
    
    // Match each choice block
    const choiceBlocks = choicesPart.split(/(?=\s*-\s*text:)/g);
    
    for (const block of choiceBlocks) {
      if (!block.trim()) continue;
      
      // Extract text
      const textMatch = block.match(/\s*-\s*text:\s*"?([^"\n]+)"?/);
      if (!textMatch) continue;
      
      const choice = {
        text: textMatch[1].trim(),
        next: null,
        rewards: {}
      };
      
      // Extract next
      const nextMatch = block.match(/\s+next:\s*([^\s\n]+)/);
      if (nextMatch) {
        choice.next = nextMatch[1].trim();
        console.log(`Direct parser found next: "${choice.next}" for choice: "${choice.text}"`);
      }
      
      // Add the choice
      choices.push(choice);
    }
    
    console.log(`Direct parser found ${choices.length} choices:`, choices);
    
    return {
      nodeId,
      title,
      text,
      choices
    };
  } catch (error) {
    console.error(`Error in direct parser for node ${nodeId}:`, error);
    return {
      nodeId,
      title: 'Error Parsing',
      text: `Error: ${error.message}`,
      choices: []
    };
  }
}

// Hardcoded story nodes as a fallback
const HARDCODED_NODES = {
  "start": START_NODE,
  
  "b1": `---
node_id: b1
title: The Stables
---

The smell of hay and horses fills your nostrils as you approach the stables. Thomas, the stable master, is a tall man with weathered hands and keen eyes. He looks you up and down as Master Geoffrey introduces you.

"So, you want to work with horses, do you?" Thomas asks, leading you past stalls where magnificent warhorses and swift coursers stand. "Let's see what you're made of. We've got a situation that needs handling."

You follow his gaze to a stall where a young, spirited horse is pawing at the ground, clearly agitated. Its coat is lathered with sweat, and none of the stable boys seem eager to approach.

"That's Thunder - new arrival and not yet used to castle life. We need to calm him down before he hurts himself. What's your thought, lad?"

[choices]
- text: "I'll try to calm Thunder myself - maybe if I approach slowly and speak softly..."
  next: c1
  rewards:
    skills: 
      - "Basic Horse Handling"
    character_traits:
      - "Brave"
    knowledge:
      - "Horse Body Language"

- text: "Perhaps we should get more experienced help - better to be careful with a frightened horse."
  next: c2
  rewards:
    character_traits:
      - "Prudent"
    knowledge:
      - "Stable Safety Protocols"
    relationships:
      - "Thomas (Stable Master) - Respect for Caution"`,
  
  "b2": `---
node_id: b2
title: The Kitchen
---

The warmth hits you first as you enter the castle kitchen, along with the rich aroma of fresh bread and herbs. Agnes, the head cook, is a stout woman with flour-dusted hands and sharp eyes that miss nothing. She pauses in her work at a large wooden table as Master Geoffrey makes introductions.

"Another pair of hands, eh?" she says, looking you over. "Well, timing couldn't be better. We've got a feast to prepare for tonight - Lord Edmund's returning from his travels." She gestures to the organized chaos around you, where kitchen boys and scullery maids hurry about their tasks.

"But first," she continues, lowering her voice, "we've got a more pressing matter. Someone's been taking extra food from the pantry - not much, mind you, but enough to notice. This morning, I saw a boy about your age sneaking away from the kitchen with a loaf of bread under his shirt."

[choices]
- text: "I could help you catch the thief and report them."
  next: c3
  rewards:
    character_traits:
      - "Dutiful"
    knowledge:
      - "Kitchen Security Protocols"
    relationships:
      - "Agnes (Head Cook) - Earned Trust"

- text: "Maybe we should find out why they're taking the food first? They might be hungry."
  next: c4
  rewards:
    character_traits:
      - "Compassionate"
      - "Diplomatic"
    knowledge:
      - "Castle Social Structure"`,
  
  "c4": `---
node_id: c4
title: Help Hungry Child
---

Instead of raising the alarm, you quietly approach the child. "Wait," you whisper, making sure no one else can hear. "I don't want to hurt you. I just want to talk."

The child freezes, clutching a small bundle of salted meat to their chest. You can see now it's a girl about your age, her clothes worn but clean. Her eyes dart toward the exit, but something in your voice makes her hesitate.

"My little brother's sick," she says finally, her voice barely a whisper. "We haven't had proper food in days. Father lost his job at the mill, and—" She stops, looking ashamed.

Your mind races back to Marta's earlier lessons about the castle's abundance. "Wait here," you tell her. You quickly gather some of the day's leftover bread and vegetables – food that would have been thrown out anyway. "Take these too. They're fresh, and no one will miss them."

The girl's eyes fill with tears of relief. As she accepts the food, she tells you about a group of village families who help each other survive hard times. They share what little they have, take care of each other's children, and keep each other's spirits up. But they're too proud to ask the castle for help directly.

Just then, you hear footsteps approaching the storage room. You have to make a choice:

[choices]
- text: "Keep the villagers' secret and find quiet ways to help them"
  next: d7
  rewards:
    skills:
      - "Stealth"
      - "Resource Distribution"
    character_traits:
      - "Compassionate"
      - "Discreet"
    knowledge:
      - "Village Social Networks"
    relationships:
      - "Village Girl - Trust and Gratitude"

- text: "Tell the castle authorities so they can provide official assistance"
  next: d8
  rewards:
    skills:
      - "Diplomacy"
      - "Advocacy"
    character_traits:
      - "Honest"
      - "Community-minded"
    knowledge:
      - "Castle Aid Protocols"
    relationships:
      - "Castle Authorities - Recognition"`,
      
  "c5": `---
node_id: c5
title: Read Message
---

Your hands tremble slightly as you carefully peel back the hidden message. The charcoal writing is faint, but you can make out what looks like a coded message: "New moon. East gate. Silver for silence." Below that are strange symbols that must mean something to whoever wrote them.

The main message to the steward suddenly feels much less important. As you read the hidden note again, pieces start falling into place. Earlier today, you delivered messages to the guard captain about scheduling, and you remember seeing fewer guards assigned to the east gate during the new moon – just two days from now.

Your stomach tightens. Could this be about smuggling? Or something worse? The symbols at the bottom remind you of marks you've seen on some merchants' crates – but these look different, almost like weapons.

Thomas's words from this morning echo in your head: "A good messenger sees everything." Well, you've certainly seen something now. But Thomas also said messengers are trusted with secrets – does that mean you should pretend you never saw this?

You glance out a narrow window and spot a group of unusual merchants in the courtyard, their clothes too fine for simple traders. One of them is staring at the east gate with great interest.

Time feels like it's slipping away, and either choice could have serious consequences for the castle. What's the right thing for a future knight to do?

[choices]
- text: "Investigate further on your own to uncover the whole plot"
  next: d9
  rewards:
    skills:
      - "Sleuthing"
      - "Code Deciphering"
    character_traits:
      - "Daring"
      - "Independent"
    knowledge:
      - "Secret Messages"
    relationships:
      - "Potential Danger from Conspirators"

- text: "Take the message directly to your messenger mentor for help"
  next: d10
  rewards:
    skills:
      - "Protocol Following"
      - "Clear Reporting"
    character_traits:
      - "Prudent"
      - "Responsible"
    knowledge:
      - "Chain of Command"
    relationships:
      - "Thomas (Mentor) - Increased Trust"`,
      
  "c6": `---
node_id: c6
title: Stay Loyal
---

Forcing yourself to ignore the hidden message, you carefully deliver both pieces of parchment exactly as they were given to you. Your hands feel sweaty, but you remember Thomas's words about the importance of trust. A messenger who reads private messages won't be trusted with any messages at all.

Just before sunset, you find Thomas waiting in the small messenger's courtyard. His expression is unusually serious. "I saw you notice the second message earlier," he says quietly. "But you delivered it untouched. Not many young ones would have done that."

He leads you to a part of the castle you've never seen before – a small room hidden behind a tapestry. Inside, you're surprised to find not just Thomas, but the castle steward and the captain of the guard. They're studying the very message you delivered.

"We've been watching you all day," the steward explains. "That message was a test. We need messengers we can trust completely – especially now." He exchanges glances with the captain. "We're tracking some dangerous people, and we need someone who can carry messages right under their noses without arousing suspicion."

The captain steps forward. "You've proven you can be trusted. But this won't be easy work. You could stick to regular message duties and train to be a traditional castle messenger. Or you could help us with something more... important."

The three men wait for your answer. Both paths serve the castle – but in very different ways.

[choices]
- text: "Accept the special mission and join their secret work"
  next: d11
  rewards:
    skills:
      - "Espionage Basics"
      - "Covert Communication"
    character_traits:
      - "Brave"
      - "Discreet"
    knowledge:
      - "Castle Security Networks"
    relationships:
      - "Thomas - Confidant and Handler"

- text: "Focus on your regular messenger training"
  next: d12
  rewards:
    skills:
      - "Advanced Message Protocols"
      - "Diplomatic Communication"
    character_traits:
      - "Steadfast"
      - "Traditional"
    knowledge:
      - "Castle Hierarchy"
    relationships:
      - "Thomas - Proud Mentor"`
};

const StoryGame = () => {
  const parseStoryContent = (nodeId, markdownText) => {
    try {
      console.log(`Parsing content for node: ${nodeId}`);
      const lines = markdownText.split('\n');
      
      // Find frontmatter boundaries (---) 
      let frontmatterStart = -1;
      let frontmatterEnd = -1;
      
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].trim() === '---') {
          if (frontmatterStart === -1) {
            frontmatterStart = i;
          } else {
            frontmatterEnd = i;
            break;
          }
        }
      }
      
      if (frontmatterStart === -1 || frontmatterEnd === -1) {
        console.error('Error: Could not find frontmatter in markdown content');
        return null;
      }
      
      // Parse frontmatter
      const frontmatter = {};
      lines.slice(frontmatterStart + 1, frontmatterEnd).forEach(line => {
        if (line.includes(':')) {
          const [key, ...valueParts] = line.split(':');
          const value = valueParts.join(':').trim();
          frontmatter[key.trim()] = value;
        }
      });
      
      // Get main content (everything between frontmatter and [choices] section)
      let mainContentEnd = lines.findIndex(line => line.trim() === '[choices]');
      if (mainContentEnd === -1) mainContentEnd = lines.length;
      
      const mainContent = lines.slice(frontmatterEnd + 1, mainContentEnd).join('\n').trim();
      
      // Parse choices section
      const choices = [];
      let currentChoice = null;
      let inChoices = false;
      let inRewards = false;
      let currentRewardCategory = null;
      
      // Debug output for choices section
      console.log("Choice section starts at line:", mainContentEnd);
      if (mainContentEnd < lines.length) {
        console.log("Choice section lines:", lines.slice(mainContentEnd, lines.length));
      }
      
      for (let i = mainContentEnd; i < lines.length; i++) {
        const line = lines[i].trim();
        console.log(`Processing line ${i}: "${line}"`);
        
        if (line === '[choices]') {
          inChoices = true;
          console.log("Found [choices] marker, entering choices section");
          continue;
        }
        
        if (!inChoices) continue;
        
        if (line.startsWith('- text:')) {
          // Start a new choice
          if (currentChoice) {
            console.log("Adding choice:", currentChoice);
            choices.push(currentChoice);
          }
          
          const choiceText = line.substring('- text:'.length).trim().replace(/^"(.+)"$/, '$1');
          console.log(`Creating new choice with text: "${choiceText}"`);
          
          currentChoice = {
            text: choiceText,
            next: null, // Initialize with null to prevent undefined errors
            rewards: {}
          };
          inRewards = false;
        } else if (line.startsWith('  next:')) {
          if (currentChoice) {
            // Extract the next value, make sure it's not empty
            const nextValue = line.substring('  next:'.length).trim();
            currentChoice.next = nextValue || null;
            console.log(`Set next: "${nextValue}" for choice "${currentChoice.text}"`);
          }
        } else if (line.startsWith('  rewards:')) {
          inRewards = true;
          console.log("Entering rewards section");
        } else if (inRewards && line.startsWith('    ')) {
          // Inside rewards section
          if (line.endsWith(':')) {
            // This is a category like "skills:"
            currentRewardCategory = line.trim().slice(0, -1);
            if (!currentChoice.rewards[currentRewardCategory]) {
              currentChoice.rewards[currentRewardCategory] = [];
            }
            console.log(`Set reward category: "${currentRewardCategory}"`);
          } else if (line.startsWith('      -') && currentRewardCategory) {
            // This is a reward item
            const rewardValue = line.substring('      -'.length).trim().replace(/^"(.+)"$/, '$1');
            // Only add non-empty rewards
            if (rewardValue && rewardValue !== '""' && rewardValue !== "''") {
              currentChoice.rewards[currentRewardCategory].push(rewardValue);
              console.log(`Added reward: "${rewardValue}" to category "${currentRewardCategory}"`);
            }
          }
        }
      }
      
      // Add the last choice if there is one
      if (currentChoice) {
        console.log("Adding final choice:", currentChoice);
        choices.push(currentChoice);
      }
      
      console.log("Choices processed:", choices);
      
      return {
        nodeId: nodeId,
        title: frontmatter.title || '',
        text: mainContent,
        choices: choices.length > 0 ? choices : []
      };
    } catch (error) {
      console.error(`Error parsing story content for node ${nodeId}:`, error);
      document.getElementById('error-details').textContent = `Parser error: ${error.message}`;
      document.getElementById('debug-panel').style.display = 'block';
      return null;
    }
  };
  
  // Function to load story content from various sources
  const loadStoryContent = async (nodeId) => {
    console.log(`Loading story node: ${nodeId}`);
    
    // First try: Use hardcoded content if available
    if (HARDCODED_NODES[nodeId]) {
      console.log(`Using hardcoded content for ${nodeId}`);
      
      // Use the direct parser for simplicity and reliability
      const content = directChoiceParser(nodeId, HARDCODED_NODES[nodeId]);
      console.log("Parsed content:", content);
      
      if (content && content.choices) {
        console.log("Choices ready for rendering:", content.choices);
      }
      return content;
    }
    
    // Try loading from file (this might not work on GitHub Pages due to path issues)
    try {
      // Try different possible path patterns for GitHub Pages
      const possiblePaths = [
        `/_data/story/nodes/${nodeId}.md`,        // Most likely path based on your structure
        `/data/story/nodes/${nodeId}.md`,         // Alternative without leading underscore
        `/story/nodes/${nodeId}.md`,              // Another possible variation
        `/nodes/${nodeId}.md`,                    // Shortened path
        `/${nodeId}.md`,                          // Root path (least likely)
        `/socialstudies/_data/story/nodes/${nodeId}.md`,  // With potential prefix
        `/socialstudies/data/story/nodes/${nodeId}.md`    // Alternative with prefix
      ];
      
      let response = null;
      let successPath = null;
      
      // Debug output
      console.log('Loading story node:', nodeId);
      console.log('Possible paths:', possiblePaths);
      
      // Try each path until one works
      for (const path of possiblePaths) {
        console.log(`Trying path: ${path}`);
        document.getElementById('path-attempted').textContent = path;
        
        try {
          const resp = await fetch(path);
          if (resp.ok) {
            response = await resp.text();
            successPath = path;
            console.log(`Successfully loaded from: ${path}`);
            break;
          }
        } catch (e) {
          console.log(`Failed at path: ${path}`, e);
          document.getElementById('error-details').textContent = e.message;
        }
      }
      
      // If we successfully loaded content
      if (response) {
        return parseStoryContent(nodeId, response);
      } 
      
      // No content loaded, throw error to trigger fallback
      throw new Error(`Could not load content for node "${nodeId}" from any path. Check that the file exists in _data/story/nodes/ folder.`);
      
    } catch (error) {
      console.error(`Error loading story node ${nodeId}:`, error);
      document.getElementById('error-details').textContent = error.message;
      document.getElementById('debug-panel').style.display = 'block';
      
      // Check if this node has a fallback first
      if (HARDCODED_NODES[nodeId]) {
        return parseStoryContent(nodeId, HARDCODED_NODES[nodeId]);
      }
      
      // Return generic fallback error node
      return {
        nodeId: nodeId,
        title: 'Node Not Found',
        text: `The story node "${nodeId}" could not be loaded. This might be because:

1. The file doesn't exist yet in your _data/story/nodes/ folder
2. There might be a path issue in your GitHub Pages setup
3. The link from the previous node might have a typo

If you're a student: Please let your teacher know about this issue! In the meantime, you can go back and try a different path.

If you're the teacher: You'll need to create a file named "${nodeId}.md" in your _data/story/nodes/ folder. You can also add this node to the HARDCODED_NODES object in the game layout file for immediate testing.`,
        choices: []
      };
    }
  };

  const [currentNode, setCurrentNode] = React.useState('start');
  const [storyContent, setStoryContent] = React.useState(null);
  const [loading, setLoading] = React.useState(true);
  const [history, setHistory] = React.useState([]);
  const [journal, setJournal] = React.useState({
    skills: [],
    relationships: [],
    knowledge: [],
    items: [],
    character_traits: []
  });
  const [errorMessage, setErrorMessage] = React.useState('');

  // Load content when the current node changes
  React.useEffect(() => {
    const fetchContent = async () => {
      setLoading(true);
      setErrorMessage('');
      try {
        const content = await loadStoryContent(currentNode);
        if (content) {
          setStoryContent(content);
        } else {
          setErrorMessage(`Failed to load node: ${currentNode}`);
        }
      } catch (error) {
        console.error("Error in fetchContent:", error);
        setErrorMessage(`Error: ${error.message}`);
      } finally {
        setLoading(false);
      }
    };
    
    fetchContent();
  }, [currentNode]);
  
  // Set up manual node loading form handler
  React.useEffect(() => {
    const form = document.getElementById('manual-node-form');
    if (form) {
      form.addEventListener('submit', (e) => {
        e.preventDefault();
        const content = document.getElementById('node-content').value;
        if (content) {
          const parsedContent = parseStoryContent(currentNode, content);
          if (parsedContent) {
            setStoryContent(parsedContent);
            document.getElementById('debug-panel').style.display = 'none';
          }
        }
      });
    }
  }, []);

  const handleChoice = async (choice) => {
    // Add current node to history before moving
    setHistory(prev => [...prev, currentNode]);
    
    // Update journal with rewards
    if (choice.rewards) {
      setJournal(prev => {
        const newJournal = { ...prev };
        
        // Process each reward category
        Object.entries(choice.rewards).forEach(([category, items]) => {
          if (Array.isArray(items) && items.length > 0) {
            if (!newJournal[category]) newJournal[category] = [];
            // Add unique items only and filter out empty strings
            const filteredItems = items.filter(item => item && item.trim() !== '');
            newJournal[category] = [...new Set([...newJournal[category], ...filteredItems])];
          }
        });
        
        return newJournal;
      });
    }

    // Check if next node is defined
    if (!choice.next) {
      setErrorMessage(`Missing destination for choice: "${choice.text}". Check your markdown file for a missing "next:" property.`);
      return;
    }

    // Update current node - make sure the nodeId is lowercase to match your file naming
    const nextNode = choice.next.toLowerCase();
    console.log(`Navigating to node: ${nextNode}`);
    setCurrentNode(nextNode);
    
    // Debug: Check if the next node exists in hardcoded nodes
    if (HARDCODED_NODES[nextNode]) {
      console.log(`Node ${nextNode} exists in hardcoded nodes.`);
    } else {
      console.log(`Warning: Node ${nextNode} not found in hardcoded nodes. Will attempt to load from file.`);
    }
  };
  
  const goBack = () => {
    if (history.length > 0) {
      // Get the last node from history
      const previousNode = history[history.length - 1];
      
      // Remove the last node from history
      setHistory(prev => prev.slice(0, -1));
      
      // Set current node to previous node
      setCurrentNode(previousNode);
    }
  };

  const resetGame = () => {
    console.log("Resetting game...");
    setCurrentNode('start');
    setHistory([]);
    setErrorMessage('');
    setJournal({
      skills: [],
      relationships: [],
      knowledge: [],
      items: [],
      character_traits: []
    });
  };

  // Journal Section Component
  const JournalSection = ({ title, items }) => {
    if (!items || items.length === 0) return null;
    return React.createElement('div', { className: 'journal-section' },
      React.createElement('h3', { key: 'title' }, title),
      React.createElement('ul', { key: 'list' }, 
        items.map((item, index) => 
          React.createElement('li', { key: index }, item)
        )
      )
    );
  };

  if (loading) {
    return React.createElement('div', { className: 'loading' }, 
      React.createElement('div', { className: 'spinner' }),
      'Loading story...'
    );
  }

  if (errorMessage) {
    return       React.createElement('div', { key: 'error' }, 
      `Error: ${errorMessage}`,
      React.createElement('button', {
        onClick: () => {
          resetGame();
          setErrorMessage('');
        },
        className: 'reset-button',
        style: { marginTop: '20px' }
      }, 'Return to Start')
    );
  }

  if (!storyContent) {
    return React.createElement('div', { className: 'error' }, 
      'Could not load story content',
      React.createElement('button', {
        onClick: resetGame,
        className: 'reset-button',
        style: { marginTop: '20px' }
      }, 'Return to Start')
    );
  }

  return React.createElement('div', { className: 'game-container' }, [
    // Main story section
    React.createElement('div', { key: 'story-section', className: 'story-section' }, [
      React.createElement('div', { key: 'node-id', className: 'node-id' },
        `Node: ${storyContent.nodeId}`
      ),
      React.createElement('h2', { key: 'title', className: 'game-title' }, 
        storyContent.title
      ),
      React.createElement('div', { key: 'story', className: 'story-text', 
        dangerouslySetInnerHTML: { __html: storyContent.text.replace(/\n/g, '<br>') }
      }),
      storyContent.choices && storyContent.choices.length > 0 ? 
        React.createElement('div', { key: 'choices', className: 'choice-container' }, 
          storyContent.choices.map((choice, index) => {
            console.log(`Rendering choice ${index}:`, choice);
            return React.createElement('button', {
              key: `choice-${index}`,
              onClick: () => handleChoice(choice),
              className: 'choice-button'
            }, choice.text);
          })
        ) : (
          // End of story node - display a message if there are no choices
          React.createElement('div', { key: 'story-end', className: 'story-end' },
            React.createElement('p', {}, "You've reached the end of this path of your adventure."),
            React.createElement('button', {
              onClick: resetGame,
              className: 'reset-button'
            }, 'Start a New Journey')
          )
        ),
      React.createElement('div', { key: 'game-controls', className: 'game-controls' }, [
        history.length > 0 && React.createElement('button', {
          key: 'back-button',
          onClick: goBack,
          className: 'back-button'
        }, 'Go Back'),
        React.createElement('button', {
          key: 'reset-button',
          onClick: resetGame,
          className: 'reset-button'
        }, 'Start Over')
      ])
    ]),
    
    // Journal section
    React.createElement('div', { key: 'journal', className: 'journal' }, [
      React.createElement('h2', { key: 'journal-title', className: 'journal-title' }, 
        'Your Journal'
      ),
      React.createElement(JournalSection, { 
        key: 'skills',
        title: 'Skills Learned',
        items: journal.skills 
      }),
      React.createElement(JournalSection, { 
        key: 'character_traits',
        title: 'Character Traits',
        items: journal.character_traits 
      }),
      React.createElement(JournalSection, { 
        key: 'knowledge',
        title: 'Knowledge Gained',
        items: journal.knowledge 
      }),
      React.createElement(JournalSection, { 
        key: 'relationships',
        title: 'Relationships',
        items: journal.relationships 
      }),
      React.createElement(JournalSection, { 
        key: 'items',
        title: 'Items Acquired',
        items: journal.items 
      })
    ])
  ]);
};

// Render the game
ReactDOM.render(
  React.createElement(StoryGame),
  document.getElementById('story-game-root')
);
</script>

<style>
.game-container {
  display: flex;
  max-width: 1200px;
  margin: 20px auto;
  gap: 20px;
  padding: 20px;
  min-height: 600px;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.story-section {
  flex: 2;
  background: white;
  padding: 30px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  position: relative;
  min-height: 400px;
  border: 1px solid #e2e8f0;
}

.journal {
  flex: 1;
  background: #f8f9fa;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  max-height: 80vh;
  overflow-y: auto;
  border: 1px solid #e2e8f0;
}

.node-id {
  position: absolute;
  top: 10px;
  right: 10px;
  font-size: 12px;
  color: #718096;
  background: #f7fafc;
  padding: 3px 8px;
  border-radius: 4px;
  border: 1px solid #e2e8f0;
}

.game-title {
  color: #2d3748;
  font-size: 24px;
  margin-bottom: 20px;
  border-bottom: 2px solid #e2e8f0;
  padding-bottom: 10px;
}

.journal-title {
  color: #2d3748;
  font-size: 20px;
  margin-bottom: 15px;
  padding-bottom: 10px;
  border-bottom: 2px solid #e2e8f0;
}

.story-text {
  font-size: 16px;
  line-height: 1.6;
  margin-bottom: 30px;
  color: #2d3748;
}

.choice-container {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-bottom: 60px;
}

.choice-button {
  background: #4a5568;
  color: white;
  padding: 12px 20px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
  transition: background 0.2s;
  text-align: left;
  line-height: 1.4;
}

.choice-button:hover {
  background: #2d3748;
}

.game-controls {
  position: absolute;
  bottom: 20px;
  left: 20px;
  display: flex;
  gap: 10px;
}

.back-button {
  background: #3182ce;
  color: white;
  padding: 8px 16px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  transition: background 0.2s;
}

.back-button:hover {
  background: #2c5282;
}

.reset-button {
  background: #e53e3e;
  color: white;
  padding: 8px 16px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  transition: background 0.2s;
}

.reset-button:hover {
  background: #c53030;
}

.loading {
  text-align: center;
  padding: 2rem;
  font-size: 1.2rem;
  color: #4a5568;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid rgba(0, 0, 0, 0.1);
  border-radius: 50%;
  border-top-color: #3182ce;
  animation: spin 1s linear infinite;
  margin-bottom: 15px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.error {
  text-align: center;
  padding: 2rem;
  color: #e53e3e;
  font-size: 1.2rem;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.story-end {
  text-align: center;
  padding: 20px;
  background: #f7fafc;
  border-radius: 8px;
  margin-bottom: 50px;
}

.journal-section {
  margin-bottom: 20px;
}

.journal-section h3 {
  color: #4a5568;
  font-size: 16px;
  margin-bottom: 8px;
  padding-bottom: 4px;
  border-bottom: 1px solid #e2e8f0;
}

.journal-section ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

.journal-section li {
  font-size: 14px;
  color: #4a5568;
  padding: 6px 0;
  border-bottom: 1px solid #edf2f7;
}

@media (max-width: 768px) {
  .game-container {
    flex-direction: column;
  }
  
  .journal {
    max-height: none;
  }
  
  .story-section {
    min-height: 300px;
  }

  .choice-container {
    margin-bottom: 80px;
  }

  .choice-button {
    font-size: 14px;
    padding: 10px 16px;
  }
}
</style>
